#!/usr/bin/env python3
"""Search previously downloaded YouTube comments using boolean expressions.

Run the script inside a directory that contains the ``comments.csv``
generated by ``ytcomments.py``.
"""

from __future__ import annotations

import csv
import sys
from pathlib import Path
from typing import Dict, List

from ytcomments import (
    interactive_search,
    keyword_search,
    print_matches,
    sanitize_for_filename,
)

COMMENTS_FILENAME = "comments.csv"


def load_flattened_comments(csv_path: Path) -> List[Dict[str, str]]:
    """Load the flattened comments from the provided CSV path."""
    rows: List[Dict[str, str]] = []
    with csv_path.open("r", encoding="utf-8", newline="") as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            rows.append(row)
    return rows


def prompt(prompt_text: str) -> str:
    """Safely prompt the user and handle EOF/interrupts."""
    try:
        return input(prompt_text)
    except (EOFError, KeyboardInterrupt):
        print("\nInput cancelled. Exiting.")
        sys.exit(0)


def main() -> None:
    """Drive the keyword-search workflow for saved comment exports."""
    print("YouTube Comment Search (saved data)\n")

    try:
        csv_path = Path.cwd() / COMMENTS_FILENAME
        if not csv_path.is_file():
            raise FileNotFoundError(f"Expected {COMMENTS_FILENAME} in {Path.cwd()}")
        flat_rows = load_flattened_comments(csv_path)
    except Exception as err:
        print(f"Failed to load {COMMENTS_FILENAME}: {err}", file=sys.stderr)
        sys.exit(1)

    if not flat_rows:
        print(f"No comments found in {COMMENTS_FILENAME}. Exiting.")
        return

    report_lines: List[str] = [
        "YouTube Comment Search (saved data)",
        f"Source CSV: {csv_path}",
    ]

    query = prompt(
        "Enter keywords with AND/OR (use quotes for phrases, parentheses allowed, leave blank to skip search): "
    ).strip()

    search_performed = bool(query)
    matches: List[Dict[str, str]] = []
    if search_performed:
        report_lines.append(f"Search query: {query}")
        try:
            matches = keyword_search(flat_rows, query)
        except ValueError as err:
            print(f"\nKeyword search error: {err}")
            search_performed = False

    if search_performed:
        print_matches(matches, collector=report_lines)

    print(f"\nLoaded comments from: {csv_path}")
    total_line = f"Total comments available: {len(flat_rows)}"
    print(total_line)
    report_lines.append("")
    report_lines.append(total_line)
    if search_performed:
        matches_line = f"Comments matching keywords: {len(matches)}"
        print(matches_line)
        report_lines.append(matches_line)
    else:
        print("Keyword search skipped.")
        report_lines.append("Keyword search skipped.")

    if search_performed:
        slug = sanitize_for_filename(query)
        log_path = csv_path.parent / f"search_{slug}.txt"
        log_path.write_text("\n".join(report_lines), encoding="utf-8")
        print(f"Saved search log to {log_path}")

    interactive_search(flat_rows, csv_path.parent, len(flat_rows))


if __name__ == "__main__":
    main()
